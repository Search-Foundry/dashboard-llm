<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard Modelli AI</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
    <style>
        body {
            font-family: sans-serif;
            margin: 20px;
            background-color: #f4f7f6;
            color: #333;
        }

        h1 {
            text-align: center;
            color: #2c3e50;
        }

        .container {
            max-width: 1400px;
            margin: 20px auto;
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }

        .main-content {
            flex: 1;
            min-width: 0; /* Permette al contenuto di restringersi */
        }

        .filter-section {
            width: 320px;
            min-width: 280px;
            flex-shrink: 0;
            background-color: #fafafa;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
            position: sticky;
            top: 20px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            overflow-x: hidden;
        }

        .filter-section label {
            display: block;
            margin-bottom: 12px;
            font-weight: bold;
            font-size: 1.05em;
            color: #2c3e50;
        }

        /* Nuovi stili per filtri a checkbox */
        #filters {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .company-group {
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            padding: 8px 10px;
            background: #ffffff;
            margin-bottom: 0;
            transition: all 0.2s ease;
        }
        .company-group:hover {
            border-color: #3498db;
            box-shadow: 0 1px 3px rgba(52, 152, 219, 0.1);
        }
        .company-group.collapsed .model-list {
            display: none;
        }
        .company-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 6px;
            font-weight: 600;
            gap: 10px;
            cursor: pointer;
            user-select: none;
        }
        .company-header-left {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
        }
        .collapse-toggle {
            font-size: 0.85em;
            color: #666;
            transition: transform 0.2s ease;
            width: 16px;
            text-align: center;
        }
        .company-group.collapsed .collapse-toggle {
            transform: rotate(-90deg);
        }
        .highlight-toggle {
            border: 1px solid #3498db;
            background: #ffffff;
            color: #3498db;
            padding: 4px 10px;
            border-radius: 999px;
            font-size: 0.85em;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .highlight-toggle:hover {
            background: #ecf5fc;
        }
        .highlight-toggle.active {
            background: #3498db;
            color: #fff;
        }
        .model-list {
            max-height: 200px;
            overflow-y: auto;
            overflow-x: hidden;
            padding-left: 2px;
            margin-top: 4px;
        }
        /* Scrollbar personalizzata per model-list */
        .model-list::-webkit-scrollbar {
            width: 6px;
        }
        .model-list::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }
        .model-list::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 3px;
        }
        .model-list::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        /* Scrollbar personalizzata per filter-section */
        .filter-section::-webkit-scrollbar {
            width: 8px;
        }
        .filter-section::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }
        .filter-section::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }
        .filter-section::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        .model-item {
            display: flex;
            align-items: center;
            gap: 6px;
            margin: 2px 0;
            font-size: 0.95em;
        }

        .tabs {
            display: flex;
            flex-wrap: wrap; /* Permette ai tab di andare a capo su schermi piccoli */
            margin-bottom: 20px;
            border-bottom: 1px solid #ddd;
        }

        .tab {
            padding: 10px 15px;
            cursor: pointer;
            border: none;
            background-color: transparent;
            margin-right: 5px;
            margin-bottom: 5px; /* Spazio se vanno a capo */
            border-bottom: 3px solid transparent;
            font-size: 1em;
            transition: all 0.3s ease;
            white-space: nowrap; /* Evita che il testo del tab vada a capo */
        }

        .tab:hover {
            background-color: #f0f0f0;
        }

        .tab.active {
            border-bottom: 3px solid #3498db;
            font-weight: bold;
            color: #3498db;
        }

        .tab-content {
            display: none; /* Nascosto di default */
            padding: 15px 0;
        }

        .tab-content.active {
            display: block; /* Mostra il contenuto attivo */
        }

        /* Responsive canvas container */
        .chart-container {
            position: relative;
            margin: auto;
            height: 60vh; /* Altezza relativa alla viewport */
            width: 95%;   /* Larghezza relativa al container */
            max-width: 1000px; /* Limite massimo per schermi grandi */
            min-height: 350px; /* Altezza minima per evitare collassi */
        }

        /* Legenda personalizzata (opzionale) */
        .custom-legend {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 15px;
            padding: 0;
            list-style: none;
        }
        .custom-legend li {
            display: flex;
            align-items: center;
            margin-right: 15px;
            margin-bottom: 5px;
            font-size: 0.9em;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: all 0.2s ease;
            user-select: none;
        }
        .custom-legend li:hover {
            background-color: #f0f0f0;
            transform: scale(1.05);
        }
        .custom-legend li.active {
            background-color: #e3f2fd;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(52, 152, 219, 0.3);
        }
        .custom-legend span,
        .custom-legend canvas {
            display: inline-block;
            width: 12px;
            height: 12px;
            margin-right: 5px;
            border-radius: 2px; /* Quadrato arrotondato */
            transition: transform 0.2s ease;
            vertical-align: middle;
        }
        .custom-legend li.active span,
        .custom-legend li.active canvas {
            transform: scale(1.2);
            box-shadow: 0 0 4px rgba(0, 0, 0, 0.3);
        }
        .chart-note {
            margin-top: 12px;
            text-align: center;
            font-size: 0.85em;
            color: #555;
        }


        /* Media query per schermi più piccoli */
        @media (max-width: 1024px) {
            .container {
                flex-direction: column;
            }
            .filter-section {
                width: 100%;
                position: static;
                max-height: 400px;
            }
            .main-content {
                width: 100%;
            }
        }
        @media (max-width: 768px) {
            .chart-container {
                height: 50vh;
                min-height: 300px;
            }
            .tab {
                font-size: 0.9em;
                padding: 8px 10px;
            }
            .filter-section {
                max-height: 350px;
            }
        }
         @media (max-width: 480px) {
             .tab {
                 font-size: 0.8em;
             }
             .chart-container {
                 min-height: 250px;
             }
             .filter-section {
                 max-height: 300px;
             }
         }
    </style>
</head>
<body>

    <div class="container">
        <!-- Sezione Filtri -->
        <div class="filter-section">
            <label>Filtra per Azienda e Modello:</label>
            <div id="filters">
                <!-- Gruppi aziende e checkbox modelli verranno generati da JS -->
            </div>
        </div>

        <!-- Contenuto Principale -->
        <div class="main-content">
            <h1>Analisi Performance Modelli AI</h1>
            <h3>Link alla <a href="https://github.com/Search-Foundry/dashboard-llm"> Repository GitHub</a>
            </h3>

            <!-- Sezione Caricamento Dati Manuale -->
            <div id="manualUploadSection" style="display: none; margin-bottom: 25px; padding-bottom: 20px; border-bottom: 1px solid #eee;">
                <p style="color: #e74c3c; font-weight: bold;">Errore nel caricamento dati automatico. Seleziona il file 'dati.csv' per avviare il caricamento immediatamente:</p>
                <input type="file" id="csvFileInput" accept=".csv">
            </div>

            <!-- Sezione Tabs -->
            <div class="tabs">
                <button class="tab active" data-target="#contentMatching">Matching (True/False)</button>
                <button class="tab" data-target="#contentPotenzialeCosto">Potenziale vs Costo</button>
                <button class="tab" data-target="#contentSimilarita">Similarità Media</button>
                <button class="tab" data-target="#contentCandlestick">Potenziale ± Deviazione Standard</button>
            </div>

            <!-- Contenuto Tabs (Grafici) -->
            <div id="contentMatching" class="tab-content active">
                <h2>Matching (True/False) - Ordinato per True Decrescente</h2>
                <div class="chart-container">
                    <canvas id="chartMatching"></canvas>
                </div>
            </div>

            <div id="contentPotenzialeCosto" class="tab-content">
                <h2>Potenziale vs Costo</h2>
                 <div class="chart-container">
                    <canvas id="chartPotenzialeCosto"></canvas>
                 </div>
                 <!-- Legenda Personalizzata per colori scatter -->
                 <ul id="scatterLegend" class="custom-legend"></ul>
                 <p class="chart-note">I marker più grandi indicano modelli con accuracy (percentuale di true) ≥ 90%.</p>
            </div>

            <div id="contentSimilarita" class="tab-content">
                <h2>Similarità Semantica Media - Ordinata Decrescente</h2>
                 <div class="chart-container">
                    <canvas id="chartSimilarita"></canvas>
                 </div>
            </div>

            <div id="contentCandlestick" class="tab-content">
                <h2 id="candlestickChartTitle">Potenziale ± Deviazione Standard - Ordinato per Potenziale Crescente</h2>
                
                <!-- Controlli del Grafico -->
                <div class="chart-controls" style="margin-bottom: 15px; display: flex; align-items: center; gap: 10px;">
                    <label for="sortOrderSelect" style="font-weight: bold;">Ordina per:</label>
                    <select id="sortOrderSelect" style="padding: 5px; border-radius: 4px; border: 1px solid #ccc;">
                        <option value="potenziale_asc">Potenziale (crescente)</option>
                        <option value="potenziale_desc">Potenziale (decrescente)</option>
                        <option value="deviazione_asc">Deviazione Standard (crescente)</option>
                        <option value="deviazione_desc">Deviazione Standard (decrescente)</option>
                    </select>
                </div>

                <div class="chart-container">
                    <canvas id="chartCandlestick"></canvas>
                </div>
                <p class="chart-note">Ogni barra è centrata e la sua larghezza è proporzionale alla deviazione standard del modello. Le barre più lunghe indicano una maggiore variabilità. L'ordinamento verticale si basa sul criterio selezionato (es. potenziale originale).</p>
            </div>
        </div>

    </div><!-- /container -->

    <!-- Dataset JSON (non più utilizzato, lasciato per riferimento) -->
    <script type="application/json" id="modelData">[]</script>

    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Elementi DOM ---
            const filtersContainer = document.getElementById('filters');
            const tabs = document.querySelectorAll('.tab');
            const tabContents = document.querySelectorAll('.tab-content');
            const ctxMatching = document.getElementById('chartMatching').getContext('2d');
            const ctxPotenzialeCosto = document.getElementById('chartPotenzialeCosto').getContext('2d');
            const ctxSimilarita = document.getElementById('chartSimilarita').getContext('2d');
            const ctxCandlestick = document.getElementById('chartCandlestick').getContext('2d');
            const scatterLegendContainer = document.getElementById('scatterLegend'); // Container legenda custom
            const manualUploadSection = document.getElementById('manualUploadSection');
            const csvFileInput = document.getElementById('csvFileInput');
            const sortOrderSelect = document.getElementById('sortOrderSelect');

            // --- Dati e Stato ---
            let allData = [];
            let chartInstances = {}; // Per tenere traccia dei grafici attivi e distruggerli
            const highlightedCompanies = new Set(); // Aziende con highlight attivo
            let highlightIntervalId = null;
            let highlightPulseState = false;
            let filtersChangeBound = false;

            // --- Colori per aziende ---
            // Palette ottimizzata per 12 gruppi con massima differenziazione visiva
            const companyColorMap = {
                'OpenAI': '#3498db',           // Blu brillante
                'Anthropic': '#e67e22',        // Arancione
                'Mistral AI': '#27ae60',       // Verde smeraldo
                'Meta': '#9b59b6',             // Viola
                'Google': '#e74c3c',           // Rosso
                'DeepSeek': '#16a085',         // Turchese scuro
                'Alibaba': '#f39c12',          // Arancione dorato
                'Microsoft': '#2980b9',        // Blu scuro
                'Hidden': '#34495e',           // Grigio antracite
                'Xai': '#c0392b',              // Rosso scuro
                'Minimax': '#8e44ad',          // Viola scuro
                'IBM': '#d35400',              // Arancione bruciato
                'Other': '#2c3e50'             // Grigio blu scuro
            };

            // --- Simboli per aziende ---
            // Metà cerchi, metà altri simboli per migliorare la differenziazione visiva
            const companySymbolMap = {
                'OpenAI': 'circle',            // Cerchio
                'Anthropic': 'cross',          // Croce
                'Mistral AI': 'circle',        // Cerchio
                'Meta': 'triangle',            // Triangolo
                'Google': 'circle',            // Cerchio
                'DeepSeek': 'star',            // Stella
                'Alibaba': 'circle',           // Cerchio
                'Microsoft': 'rect',           // Quadrato
                'Hidden': 'circle',            // Cerchio
                'Xai': 'crossRot',             // Croce ruotata
                'Minimax': 'rectRounded',      // Quadrato arrotondato
                'IBM': 'circle',               // Cerchio
                'Other': 'triangle'           // Triangolo
            };

            const ACCURACY_THRESHOLD = 90;
            const POTENZIALE_THRESHOLD = 29250;
            const POTENZIALE_THRESHOLD_LABEL = POTENZIALE_THRESHOLD.toLocaleString('it-IT');
            const potenzialeThresholdPlugin = {
                id: 'potenzialeThresholdLine',
                afterDatasetsDraw(chart, args, pluginOptions) {
                    const options = pluginOptions || chart.options.plugins?.potenzialeThresholdLine;
                    if (!options) return;
                    const threshold = typeof options.value === 'number' ? options.value : POTENZIALE_THRESHOLD;
                    const xScale = chart.scales?.x;
                    if (!xScale || !chart.chartArea) return;
                    const xPixel = xScale.getPixelForValue(threshold);
                    if (!Number.isFinite(xPixel)) return;
                    const { top, bottom, left, right } = chart.chartArea;
                    if (xPixel < left || xPixel > right) return;

                    const ctx = chart.ctx;
                    ctx.save();
                    ctx.strokeStyle = options.color || '#27ae60';
                    ctx.lineWidth = options.lineWidth || 1.5;
                    ctx.setLineDash(options.dash || [6, 4]);
                    ctx.beginPath();
                    ctx.moveTo(xPixel, top);
                    ctx.lineTo(xPixel, bottom);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    const formattedThreshold = typeof threshold === 'number' && threshold.toLocaleString
                        ? threshold.toLocaleString('it-IT')
                        : threshold;
                    const label = options.label || `Potenziale ≥ ${formattedThreshold}`;
                    ctx.fillStyle = options.color || '#27ae60';
                    ctx.font = options.font || '12px sans-serif';
                    ctx.textBaseline = 'top';
                    ctx.textAlign = 'center';
                    ctx.fillText(label, xPixel, top + 8);
                    ctx.restore();
                }
            };
            Chart.register(potenzialeThresholdPlugin);

            function getCompany(item) {
                return (item.azienda && String(item.azienda).trim()) || 'Other';
            }

            function getAccuracyPercentage(item) {
                if (typeof item.percent_true === 'number') {
                    return item.percent_true;
                }
                const parsed = parseFloat(item.percent_true);
                if (!Number.isNaN(parsed)) {
                    return parsed;
                }
                if (typeof item.true === 'number' && typeof item.total_query === 'number' && item.total_query) {
                    return (item.true / item.total_query) * 100;
                }
                return null;
            }

            // --- Inizializzazione ---
            try {
                loadData();
                csvFileInput.addEventListener('change', handleManualUpload);
            } catch (error) {
                console.error("Errore durante l'inizializzazione:", error);
                alert("Impossibile caricare i dati o inizializzare la dashboard.");
            }

            // --- Caricamento dati ---
            async function loadData() {
                try {
                    const response = await fetch('dati.csv');
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const csvText = await response.text();
                    parseCsvData(csvText);
                } catch (error) {
                    console.warn("Impossibile caricare dati.csv automaticamente. Abilitazione caricamento manuale.", error);
                    manualUploadSection.style.display = 'block';
                }
            }

            function handleManualUpload() {
                const file = csvFileInput.files[0];
                if (file) {
                    Papa.parse(file, {
                        header: true,
                        dynamicTyping: true,
                        complete: function(results) {
                            if (results.errors.length) {
                                console.error("Error parsing CSV:", results.errors);
                                alert("Errore durante il parsing del file CSV. Controlla il formato.");
                                return;
                            }
                            allData = results.data.filter(row => Object.values(row).some(x => x !== null && x !== '')); // Filtra righe vuote
                            if (allData.length === 0) {
                                alert("Il file CSV caricato è vuoto o non contiene dati validi.");
                                return;
                            }
                            manualUploadSection.style.display = 'none';
                            initializeDashboard();
                        },
                        error: function(err) {
                            console.error("Errore nella lettura del file:", err);
                            alert("Errore nella lettura del file.");
                        }
                    });
                } else {
                    alert("Seleziona un file CSV prima di caricare.");
                }
            }

            function parseCsvData(csvText) {
                Papa.parse(csvText, {
                    header: true,
                    dynamicTyping: true,
                    complete: function(results) {
                        if (results.errors.length) {
                            console.error("Error parsing CSV:", results.errors);
                            alert("Errore durante il parsing del file CSV. Controlla il formato.");
                            return;
                        }
                        allData = results.data.filter(row => Object.values(row).some(x => x !== null && x !== ''));
                        if (allData.length === 0) {
                            alert("Il file CSV è vuoto o non contiene dati validi.");
                            manualUploadSection.style.display = 'block';
                            return;
                        }
                        initializeDashboard();
                    },
                    error: function(err) {
                        console.error("Errore nel parsing CSV:", err);
                        alert("Errore nel parsing del CSV caricato automaticamente.");
                        manualUploadSection.style.display = 'block';
                    }
                });
            }

            function initializeDashboard() {
                resetHighlights();
                buildFilters();
                setupTabs();
                buildCharts(); // Costruisci i grafici iniziali
                // Rende reattivo: ricostruisci i grafici ad ogni cambio checkbox
                if (!filtersChangeBound) {
                    filtersContainer.addEventListener('change', () => {
                        buildCharts();
                    });
                    sortOrderSelect.addEventListener('change', () => {
                        buildCharts();
                    });
                    filtersChangeBound = true;
                }
            }

            // --- Costruzione filtri a checkbox ---
            function buildFilters() {
                filtersContainer.innerHTML = '';
                const byCompany = groupBy(allData, item => getCompany(item));
                const companyNames = Object.keys(byCompany).sort((a,b) => a.localeCompare(b));

                companyNames.forEach(company => {
                    const models = byCompany[company].map(d => d.modello).sort((a,b) => a.localeCompare(b));

                    const group = document.createElement('div');
                    group.className = 'company-group';

                    const header = document.createElement('div');
                    header.className = 'company-header';
                    
                    const headerLeft = document.createElement('div');
                    headerLeft.className = 'company-header-left';
                    
                    const collapseToggle = document.createElement('span');
                    collapseToggle.className = 'collapse-toggle';
                    collapseToggle.textContent = '▾';
                    collapseToggle.setAttribute('aria-label', 'Espandi/Collassa');
                    
                    const headerLabel = document.createElement('label');
                    const companyCheckbox = document.createElement('input');
                    companyCheckbox.type = 'checkbox';
                    companyCheckbox.className = 'company-checkbox';
                    companyCheckbox.dataset.company = company;
                    companyCheckbox.checked = true; // selezionato di default
                    headerLabel.appendChild(companyCheckbox);
                    const headerText = document.createTextNode(' ' + company);
                    headerLabel.appendChild(headerText);
                    
                    headerLeft.appendChild(collapseToggle);
                    headerLeft.appendChild(headerLabel);
                    header.appendChild(headerLeft);

                    const highlightButton = document.createElement('button');
                    highlightButton.type = 'button';
                    highlightButton.className = 'highlight-toggle';
                    highlightButton.dataset.company = company;
                    highlightButton.textContent = 'Highlight';
                    highlightButton.addEventListener('click', (e) => {
                        e.stopPropagation(); // Previene il toggle del gruppo quando si clicca Highlight
                        toggleCompanyHighlight(company, highlightButton);
                    });
                    updateHighlightButtonState(highlightButton, company);
                    header.appendChild(highlightButton);
                    
                    // Toggle collasso gruppo
                    header.addEventListener('click', (e) => {
                        // Non toggle se il click è sul checkbox o sul pulsante Highlight
                        if (e.target === companyCheckbox || e.target === highlightButton || e.target.closest('.highlight-toggle')) {
                            return;
                        }
                        group.classList.toggle('collapsed');
                    });
                    
                    group.appendChild(header);

                    const list = document.createElement('div');
                    list.className = 'model-list';
                    models.forEach(model => {
                        const item = document.createElement('label');
                        item.className = 'model-item';
                        const cb = document.createElement('input');
                        cb.type = 'checkbox';
                        cb.className = 'model-checkbox';
                        cb.value = model;
                        cb.dataset.company = company;
                        // Disattiva di default solo GEMINI 3.0 perché ha dati a zero che sfalsano i grafici
                        cb.checked = model !== 'GEMINI 3.0';
                        item.appendChild(cb);
                        item.appendChild(document.createTextNode(model));
                        list.appendChild(item);
                    });
                    group.appendChild(list);

                    // Bulk: spunta azienda -> spunta tutti i modelli
                    companyCheckbox.addEventListener('change', (e) => {
                        const checked = e.target.checked;
                        list.querySelectorAll('input.model-checkbox').forEach(cb => {
                            cb.checked = checked;
                        });
                        // trigger change per ricostruire grafici
                        filtersContainer.dispatchEvent(new Event('change'));
                    });

                    // Mantieni stato indeterminate per header
                    const updateCompanyCheckboxState = () => {
                        const cbs = Array.from(list.querySelectorAll('input.model-checkbox'));
                        const numChecked = cbs.filter(cb => cb.checked).length;
                        companyCheckbox.indeterminate = numChecked > 0 && numChecked < cbs.length;
                        companyCheckbox.checked = numChecked === cbs.length;
                    };
                    list.addEventListener('change', updateCompanyCheckboxState);
                    // Aggiorna lo stato iniziale del checkbox dell'azienda dopo aver creato tutti i modelli
                    updateCompanyCheckboxState();

                    filtersContainer.appendChild(group);
                });
            }

            function groupBy(array, keyGetter) {
                const map = {};
                array.forEach((item) => {
                    const key = keyGetter(item) || 'Other';
                    if (!map[key]) map[key] = [];
                    map[key].push(item);
                });
                return map;
            }

            function getSelectedModels() {
                return Array.from(document.querySelectorAll('input.model-checkbox:checked')).map(cb => cb.value);
            }

            function destroyCharts() {
                stopHighlightTimer();
                Object.keys(chartInstances).forEach(key => {
                    if (chartInstances[key]) {
                        chartInstances[key].destroy();
                        chartInstances[key] = null;
                    }
                });
                 // Pulisci anche la legenda custom
                scatterLegendContainer.innerHTML = '';
            }

            function buildCharts() {
                destroyCharts();
                const selectedModels = getSelectedModels();
                const filteredData = allData.filter(item => selectedModels.includes(item.modello));
                if (filteredData.length === 0) {
                    console.warn('Nessun modello selezionato o dati filtrati vuoti.');
                    return;
                }
                buildMatchingChart(filteredData);
                buildPotenzialeCostoChart(filteredData);
                buildSimilaritaChart(filteredData);
                buildCandlestickChart(filteredData);
            }

            // --- Grafici ---
            function buildMatchingChart(data) {
                const sortedData = [...data].sort((a, b) => b.true - a.true);
                const labels = sortedData.map(item => item.modello);
                const trueData = sortedData.map(item => item.true);
                const falseData = sortedData.map(item => item.false);

                // Altezza dinamica per includere tutte le etichette quando mostriamo barre orizzontali
                const barsCount = Math.max(labels.length, 1);
                const pixelsPerBar = 28;
                const minHeightPx = 350;
                const targetHeight = Math.max(minHeightPx, barsCount * pixelsPerBar);
                ctxMatching.canvas.parentNode.style.height = `${targetHeight}px`;

                chartInstances.matching = new Chart(ctxMatching, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [
                            { label: 'True', data: trueData, backgroundColor: 'rgba(75, 192, 192, 0.7)', borderColor: 'rgba(75, 192, 192, 1)', borderWidth: 1 },
                            { label: 'False', data: falseData, backgroundColor: 'rgba(255, 99, 132, 0.7)', borderColor: 'rgba(255, 99, 132, 1)', borderWidth: 1 }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        indexAxis: 'y',
                        plugins: {
                            title: { display: false },
                            tooltip: { mode: 'index', intersect: false }
                        },
                        scales: {
                            x: {
                                stacked: true,
                                beginAtZero: true,
                                title: { display: true, text: 'Numero Query' }
                            },
                            y: {
                                stacked: true,
                                grid: { display: false },
                                ticks: { autoSkip: false, font: { size: 11 } }
                            }
                        },
                        animation: { duration: 300 }
                    }
                });
            }

            function buildPotenzialeCostoChart(data) {
                const scatterData = [];
                const companiesPresent = new Set();

                data.forEach(item => {
                    const company = getCompany(item);
                    const color = companyColorMap[company] || companyColorMap['Other'];
                    const symbol = companySymbolMap[company] || companySymbolMap['Other'];
                    const accuracy = getAccuracyPercentage(item);
                    const baseRadius = accuracy !== null && accuracy >= ACCURACY_THRESHOLD ? 9 : 7;
                    const baseBorderWidth = accuracy !== null && accuracy >= ACCURACY_THRESHOLD ? 2.5 : 1.5;
                    const similarityValue = typeof item.similarita_media === 'number'
                        ? item.similarita_media
                        : parseFloat(item.similarita_media);
                    scatterData.push({
                        x: item.potenziale,
                        y: item.costo_euro,
                        label: item.modello,
                        company: company,
                        baseColor: color,
                        baseBorderColor: adjustColor(color, -20),
                        baseSymbol: symbol,
                        accuracy: accuracy,
                        similarity: Number.isFinite(similarityValue) ? similarityValue : null,
                        baseRadius,
                        baseBorderWidth
                    });
                    companiesPresent.add(company);
                });

                buildCustomLegend(companiesPresent);

                chartInstances.potenzialeCosto = new Chart(ctxPotenzialeCosto, {
                    type: 'scatter',
                    data: {
                        datasets: [{
                            label: 'Modelli',
                            data: scatterData,
                            pointBackgroundColor: scatterData.map(point => point.baseColor),
                            pointBorderColor: scatterData.map(point => point.baseBorderColor),
                            pointBorderWidth: scatterData.map(point => point.baseBorderWidth),
                            pointRadius: scatterData.map(point => point.baseRadius),
                            pointHoverRadius: scatterData.map(point => point.baseRadius + 3),
                            pointStyle: scatterData.map(point => point.baseSymbol)
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: { display: false },
                            legend: { display: false },
                            potenzialeThresholdLine: {
                                value: POTENZIALE_THRESHOLD,
                                label: `90% accuracy ≈ ${POTENZIALE_THRESHOLD_LABEL}`,
                                color: '#27ae60'
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const item = context.raw;
                                        const accuracyText = typeof item.accuracy === 'number'
                                            ? `, Acc: ${item.accuracy.toFixed(1)}%`
                                            : '';
                                        const similarityText = typeof item.similarity === 'number'
                                            ? `, Sim: ${item.similarity.toFixed(1)}%`
                                            : '';
                                        return `${item.label} [${item.company}]: (Pot: ${item.x}, Costo: ${Number(item.y).toFixed(2)} €${accuracyText}${similarityText})`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: { type: 'linear', position: 'bottom', title: { display: true, text: 'Potenziale' }, grid: { color: 'rgba(0,0,0,0.05)'} },
                            y: { beginAtZero: true, title: { display: true, text: 'Costo (€)' }, grid: { color: 'rgba(0,0,0,0.05)'} }
                        },
                        animation: { duration: 300 }
                    }
                });
                ensureHighlightTimer();
            }

            function buildSimilaritaChart(data) {
                const sortedData = [...data].sort((a, b) => b.similarita_media - a.similarita_media);
                const labels = sortedData.map(item => item.modello);
                const similaritaData = sortedData.map(item => item.similarita_media);

                // Ridimensiona dinamicamente l'altezza del container per evitare il taglio delle etichette
                // Altezza per barra (in px) + altezza minima per schermi piccoli
                const barsCount = Math.max(labels.length, 1);
                const pixelsPerBar = 28; // regola se vuoi più/meno spazio verticale per etichetta
                const minHeightPx = 350;
                const targetHeight = Math.max(minHeightPx, barsCount * pixelsPerBar);
                ctxSimilarita.canvas.parentNode.style.height = `${targetHeight}px`;

                chartInstances.similarita = new Chart(ctxSimilarita, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Similarità Media (%)', data: similaritaData,
                            backgroundColor: 'rgba(255, 159, 64, 0.7)', borderColor: 'rgba(255, 159, 64, 1)', borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true, maintainAspectRatio: false, indexAxis: 'y',
                        plugins: { title: { display: false }, legend: { display: false } },
                        scales: {
                            x: { beginAtZero: true, title: { display: true, text: 'Similarità Media (%)' } },
                            y: {
                                grid: { display: false },
                                ticks: {
                                    autoSkip: false, // mostra tutte le etichette
                                    font: { size: 11 }
                                }
                            }
                        },
                        animation: { duration: 300 }
                    }
                });
            }

            function buildCandlestickChart(data) {
                const sortOrder = sortOrderSelect.value;

                // Calcola la deviazione standard massima per la normalizzazione
                const allDeviazioni = allData
                    .map(d => typeof d.deviazione_std === 'number' ? d.deviazione_std : parseFloat(d.deviazione_std))
                    .filter(d => Number.isFinite(d));
                const maxDev = Math.max(...allDeviazioni);

                // Ordina i dati in base alla selezione (usando i valori originali)
                const sortedData = [...data].sort((a, b) => {
                    const potA = typeof a.potenziale === 'number' ? a.potenziale : parseFloat(a.potenziale);
                    const potB = typeof b.potenziale === 'number' ? b.potenziale : parseFloat(b.potenziale);
                    const devA = typeof a.deviazione_std === 'number' ? a.deviazione_std : parseFloat(a.deviazione_std);
                    const devB = typeof b.deviazione_std === 'number' ? b.deviazione_std : parseFloat(b.deviazione_std);

                    switch (sortOrder) {
                        case 'potenziale_desc':
                            return potB - potA;
                        case 'deviazione_asc':
                            return devA - devB;
                        case 'deviazione_desc':
                            return devB - devA;
                        case 'potenziale_asc':
                        default:
                            return potA - potB;
                    }
                });

                // Aggiorna titolo del grafico
                const chartTitle = document.getElementById('candlestickChartTitle');
                const titleMap = {
                    'potenziale_asc': 'Variazione Normalizzata (Dev. Std) - Ordinato per Potenziale Crescente',
                    'potenziale_desc': 'Variazione Normalizzata (Dev. Std) - Ordinato per Potenziale Decrescente',
                    'deviazione_asc': 'Variazione Normalizzata (Dev. Std) - Ordinato per Dev. Standard Crescente',
                    'deviazione_desc': 'Variazione Normalizzata (Dev. Std) - Ordinato per Dev. Standard Decrescente'
                };
                chartTitle.textContent = titleMap[sortOrder] || 'Variazione Normalizzata (Dev. Std)';

                const labels = sortedData.map(item => item.modello);
                const floatingBarData = [];

                sortedData.forEach(item => {
                    const potenziale = typeof item.potenziale === 'number' ? item.potenziale : parseFloat(item.potenziale);
                    const deviazioneStd = typeof item.deviazione_std === 'number' ? item.deviazione_std : parseFloat(item.deviazione_std);

                    if (!Number.isFinite(potenziale) || !Number.isFinite(deviazioneStd)) {
                        return; // Salta dati non validi
                    }

                    // Normalizza la deviazione in base alla massima deviazione, per renderla visibile
                    // La scala è 45 per avere un po' di margine (da 5 a 95)
                    const deviazioneNorm = maxDev > 0 ? (deviazioneStd / maxDev) * 45 : 0;

                    const company = getCompany(item);
                    const color = companyColorMap[company] || companyColorMap['Other'];

                    floatingBarData.push({
                        x: [50 - deviazioneNorm, 50 + deviazioneNorm], // Centrato su 50
                        y: item.modello,
                        company: company,
                        color: color,
                        potenzialeOriginal: potenziale,
                        deviazioneStdOriginal: deviazioneStd,
                        centroGrafico: 50 // Punto centrale per la linea di mediana
                    });
                });

                if (floatingBarData.length === 0) {
                    console.warn('Nessun dato valido per il grafico a barre flottanti.');
                    return;
                }

                // Altezza dinamica per includere tutte le etichette
                const barsCount = Math.max(labels.length, 1);
                const pixelsPerBar = 28;
                const minHeightPx = 400;
                const targetHeight = Math.max(minHeightPx, barsCount * pixelsPerBar);
                ctxCandlestick.canvas.parentNode.style.height = `${targetHeight}px`;

                chartInstances.candlestick = new Chart(ctxCandlestick, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Variazione Normalizzata (Dev. Std)',
                            data: floatingBarData.map(d => d.x),
                            backgroundColor: floatingBarData.map(d => d.color),
                            borderColor: floatingBarData.map(d => adjustColor(d.color, -30)),
                            borderWidth: 1,
                            barPercentage: 0.6,
                            categoryPercentage: 0.8
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        indexAxis: 'y',
                        plugins: {
                            title: { display: false },
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const index = context.dataIndex;
                                        const dataPoint = floatingBarData[index];
                                        if (!dataPoint) return '';
                                        return [
                                            `Azienda: ${dataPoint.company}`,
                                            `Potenziale (Originale): ${dataPoint.potenzialeOriginal.toLocaleString('it-IT')}`,
                                            `Dev. Std (Originale): ${dataPoint.deviazioneStdOriginal.toFixed(2)}`
                                        ];
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                min: 0,
                                max: 100,
                                title: { display: true, text: 'Variazione Normalizzata (basata su Dev. Std)' },
                                grid: { color: 'rgba(0,0,0,0.05)' }
                            },
                            y: {
                                grid: { display: false },
                                ticks: {
                                    autoSkip: false,
                                    font: { size: 11 }
                                }
                            }
                        },
                        animation: { duration: 300 }
                    },
                    plugins: [{
                        id: 'medianLine',
                        afterDatasetsDraw(chart) {
                            const ctx = chart.ctx;
                            const meta = chart.getDatasetMeta(0);
                            const xScale = chart.scales.x;

                            meta.data.forEach((bar, index) => {
                                const dataPoint = floatingBarData[index];
                                if (!dataPoint) return;

                                const medianX = xScale.getPixelForValue(dataPoint.centroGrafico);

                                if (!Number.isFinite(medianX)) return;

                                ctx.save();
                                ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)';
                                ctx.lineWidth = 1.5;
                                ctx.beginPath();
                                ctx.moveTo(medianX, bar.y - bar.height / 2);
                                ctx.lineTo(medianX, bar.y + bar.height / 2);
                                ctx.stroke();
                                ctx.restore();
                            });
                        }
                    }]
                });
            }

            // --- Helper per disegnare simboli nella legenda ---
            function createSymbolCanvas(symbol, color, size = 12) {
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = color;
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                
                const centerX = size / 2;
                const centerY = size / 2;
                const radius = size / 2 - 2;
                
                switch(symbol) {
                    case 'circle':
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                        ctx.fill();
                        break;
                    case 'cross':
                        ctx.beginPath();
                        ctx.moveTo(centerX, 2);
                        ctx.lineTo(centerX, size - 2);
                        ctx.moveTo(2, centerY);
                        ctx.lineTo(size - 2, centerY);
                        ctx.stroke();
                        break;
                    case 'crossRot':
                        ctx.save();
                        ctx.translate(centerX, centerY);
                        ctx.rotate(Math.PI / 4);
                        ctx.beginPath();
                        ctx.moveTo(0, -radius);
                        ctx.lineTo(0, radius);
                        ctx.moveTo(-radius, 0);
                        ctx.lineTo(radius, 0);
                        ctx.stroke();
                        ctx.restore();
                        break;
                    case 'triangle':
                        ctx.beginPath();
                        ctx.moveTo(centerX, 2);
                        ctx.lineTo(2, size - 2);
                        ctx.lineTo(size - 2, size - 2);
                        ctx.closePath();
                        ctx.fill();
                        break;
                    case 'star':
                        const spikes = 5;
                        const outerRadius = radius;
                        const innerRadius = radius * 0.5;
                        ctx.beginPath();
                        for (let i = 0; i < spikes * 2; i++) {
                            const radius = i % 2 === 0 ? outerRadius : innerRadius;
                            const angle = (i * Math.PI) / spikes - Math.PI / 2;
                            const x = centerX + radius * Math.cos(angle);
                            const y = centerY + radius * Math.sin(angle);
                            if (i === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        ctx.closePath();
                        ctx.fill();
                        break;
                    case 'rect':
                        ctx.fillRect(2, 2, size - 4, size - 4);
                        break;
                    case 'rectRounded':
                        const cornerRadius = 2;
                        ctx.beginPath();
                        ctx.moveTo(2 + cornerRadius, 2);
                        ctx.lineTo(size - 2 - cornerRadius, 2);
                        ctx.quadraticCurveTo(size - 2, 2, size - 2, 2 + cornerRadius);
                        ctx.lineTo(size - 2, size - 2 - cornerRadius);
                        ctx.quadraticCurveTo(size - 2, size - 2, size - 2 - cornerRadius, size - 2);
                        ctx.lineTo(2 + cornerRadius, size - 2);
                        ctx.quadraticCurveTo(2, size - 2, 2, size - 2 - cornerRadius);
                        ctx.lineTo(2, 2 + cornerRadius);
                        ctx.quadraticCurveTo(2, 2, 2 + cornerRadius, 2);
                        ctx.closePath();
                        ctx.fill();
                        break;
                    default:
                        // Default a cerchio
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                        ctx.fill();
                }
                
                return canvas;
            }

            // --- Legenda custom (per aziende) ---
            function buildCustomLegend(companies) {
                scatterLegendContainer.innerHTML = '';
                const sortedCompanies = Array.from(companies).sort();
                sortedCompanies.forEach(company => {
                    const color = companyColorMap[company] || companyColorMap['Other'];
                    const symbol = companySymbolMap[company] || companySymbolMap['Other'];
                    const li = document.createElement('li');
                    li.dataset.company = company;
                    
                    // Crea canvas con simbolo invece di span semplice
                    const symbolCanvas = createSymbolCanvas(symbol, color, 12);
                    symbolCanvas.style.marginRight = '5px';
                    symbolCanvas.style.verticalAlign = 'middle';
                    
                    const textNode = document.createTextNode(' ' + company);
                    li.appendChild(symbolCanvas);
                    li.appendChild(textNode);
                    
                    // Rendi cliccabile per toggle highlight
                    li.addEventListener('click', () => {
                        // Trova il pulsante Highlight corrispondente nella sidebar
                        const highlightButton = document.querySelector(`.highlight-toggle[data-company="${company}"]`);
                        if (highlightButton) {
                            toggleCompanyHighlight(company, highlightButton);
                            updateLegendItemState(li, company);
                        }
                    });
                    
                    // Aggiorna lo stato iniziale
                    updateLegendItemState(li, company);
                    
                    scatterLegendContainer.appendChild(li);
                });
            }
            
            function updateLegendItemState(legendItem, company) {
                const isActive = highlightedCompanies.has(company);
                legendItem.classList.toggle('active', isActive);
            }
            
            function refreshLegendItems() {
                document.querySelectorAll('#scatterLegend li').forEach(li => {
                    const company = li.dataset.company;
                    if (company) {
                        updateLegendItemState(li, company);
                    }
                });
            }

            // --- Helper colore ---
            function adjustColor(color, amount) {
                return '#' + color.replace(/^#/, '').replace(/../g, c => ('0'+Math.min(255, Math.max(0, parseInt(c, 16) + amount)).toString(16)).substr(-2));
            }

            function toggleCompanyHighlight(company, button) {
                if (highlightedCompanies.has(company)) {
                    highlightedCompanies.delete(company);
                } else {
                    highlightedCompanies.add(company);
                }
                updateHighlightButtonState(button, company);
                refreshLegendItems(); // Aggiorna anche la legenda
                ensureHighlightTimer();
            }

            function updateHighlightButtonState(button, company) {
                const isActive = highlightedCompanies.has(company);
                button.classList.toggle('active', isActive);
                button.setAttribute('aria-pressed', isActive ? 'true' : 'false');
            }

            function refreshHighlightButtons() {
                document.querySelectorAll('.highlight-toggle').forEach(button => {
                    const company = button.dataset.company;
                    updateHighlightButtonState(button, company);
                });
            }

            function resetHighlights() {
                highlightedCompanies.clear();
                stopHighlightTimer();
                refreshHighlightButtons();
                refreshLegendItems(); // Aggiorna anche la legenda
                updateScatterHighlight();
            }

            function ensureHighlightTimer() {
                const hasHighlightedPoints = updateScatterHighlight();
                if (highlightedCompanies.size === 0 || !hasHighlightedPoints) {
                    stopHighlightTimer();
                    return;
                }
                if (!highlightIntervalId) {
                    highlightIntervalId = setInterval(() => {
                        highlightPulseState = !highlightPulseState;
                        updateScatterHighlight();
                    }, 500);
                }
            }

            function stopHighlightTimer({ resetPulse = true } = {}) {
                if (highlightIntervalId) {
                    clearInterval(highlightIntervalId);
                    highlightIntervalId = null;
                }
                if (resetPulse) {
                    highlightPulseState = false;
                }
            }

            function updateScatterHighlight() {
                const chart = chartInstances.potenzialeCosto;
                if (!chart) return false;
                const dataset = chart.data.datasets?.[0];
                if (!dataset || !Array.isArray(dataset.data)) return false;

                let hasHighlightedPoint = false;

                dataset.pointRadius = dataset.data.map(point => {
                    const isHighlighted = highlightedCompanies.has(point.company);
                    if (isHighlighted) hasHighlightedPoint = true;
                    if (!isHighlighted) return point.baseRadius;
                    const pulseOffset = highlightPulseState ? 3 : 1;
                    return point.baseRadius + pulseOffset;
                });
                dataset.pointBackgroundColor = dataset.data.map(point => {
                    if (!highlightedCompanies.has(point.company)) return point.baseColor;
                    return highlightPulseState ? adjustColor(point.baseColor, 35) : adjustColor(point.baseColor, -35);
                });
                dataset.pointBorderColor = dataset.data.map(point => {
                    if (!highlightedCompanies.has(point.company)) return point.baseBorderColor;
                    return highlightPulseState ? adjustColor(point.baseBorderColor, 35) : adjustColor(point.baseBorderColor, -35);
                });
                dataset.pointBorderWidth = dataset.data.map(point => {
                    if (!highlightedCompanies.has(point.company)) return point.baseBorderWidth;
                    return highlightPulseState ? point.baseBorderWidth + 1 : point.baseBorderWidth + 0.5;
                });
                chart.update('none');
                return hasHighlightedPoint;
            }

            // Tabs
            function setupTabs() {
                tabs.forEach(tab => {
                    tab.addEventListener('click', () => {
                        tabs.forEach(t => t.classList.remove('active'));
                        tabContents.forEach(tc => tc.classList.remove('active'));
                        tab.classList.add('active');
                        const targetContent = document.querySelector(tab.dataset.target);
                        if (targetContent) {
                            targetContent.classList.add('active');
                        }
                        Object.values(chartInstances).forEach(chart => {
                            if (chart && typeof chart.resize === 'function') {
                                setTimeout(() => chart.resize(), 0);
                            }
                        });
                    });
                });
            }
        });
    </script>

</body>
</html>
