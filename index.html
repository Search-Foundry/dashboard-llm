<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Models Dashboard</title>
    <link rel="stylesheet" href="css/style.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
</head>
<body>

    <div class="container">
        <!-- Filters Section -->
        <div class="filter-section">
            <label>Filter by Company and Model:</label>
            <div id="filters">
                <!-- Company groups and model checkboxes will be generated by JS -->
            </div>
        </div>

        <!-- Main Content -->
        <div class="main-content">
            <h1>AI Models Performance Analysis</h1>
            <h3>Link to <a href="https://github.com/Search-Foundry/dashboard-llm"> GitHub Repository</a>
            </h3>

            <!-- Manual Data Upload Section -->
            <div id="manualUploadSection" style="display: none; margin-bottom: 25px; padding-bottom: 20px; border-bottom: 1px solid #eee;">
                <p style="color: #e74c3c; font-weight: bold;">Auto data loading failed. Select the 'dati.csv' file to start loading immediately:</p>
                <input type="file" id="csvFileInput" accept=".csv">
            </div>

            <!-- Tabs Section -->
            <div class="tabs">
                <button class="tab active" data-target="#contentMatching">Matching (True/False)</button>
                <button class="tab" data-target="#contentPotenzialeCosto">Potential vs Cost</button>
                <button class="tab" data-target="#contentSimilarita">Average Similarity</button>
                <button class="tab" data-target="#contentCandlestick">Potential ± Standard Deviation</button>
            </div>

            <!-- Tab Content (Charts) -->
            <div id="contentMatching" class="tab-content active">
                <h2>Matching (True/False) - Sorted by True Descending</h2>
                <div class="chart-container">
                    <canvas id="chartMatching"></canvas>
                </div>
            </div>

            <div id="contentPotenzialeCosto" class="tab-content">
                <h2>Potential vs Cost</h2>
                 <div class="chart-container">
                    <canvas id="chartPotenzialeCosto"></canvas>
                 </div>
                 <!-- Custom Legend for scatter colors -->
                 <ul id="scatterLegend" class="custom-legend"></ul>
                 <p class="chart-note">Larger markers indicate models with accuracy (percentage of true) ≥ 90%.</p>
            </div>

            <div id="contentSimilarita" class="tab-content">
                <h2>Average Semantic Similarity - Sorted Descending</h2>
                 <div class="chart-container">
                    <canvas id="chartSimilarita"></canvas>
                 </div>
            </div>

            <div id="contentCandlestick" class="tab-content">
                <h2 id="candlestickChartTitle">Potential ± Standard Deviation - Sorted by Potential Ascending</h2>

                <!-- Chart Controls -->
                <div class="chart-controls" style="margin-bottom: 15px; display: flex; align-items: center; gap: 10px;">
                    <label for="sortOrderSelect" style="font-weight: bold;">Sort by:</label>
                    <select id="sortOrderSelect" style="padding: 5px; border-radius: 4px; border: 1px solid #ccc;">
                        <option value="potenziale_asc">Potential (ascending)</option>
                        <option value="potenziale_desc">Potential (descending)</option>
                        <option value="deviazione_asc">Standard Deviation (ascending)</option>
                        <option value="deviazione_desc">Standard Deviation (descending)</option>
                    </select>
                </div>

                <div class="chart-container">
                    <canvas id="chartCandlestick"></canvas>
                </div>
                <p class="chart-note">Each bar is centered and its width is proportional to the model's standard deviation. Longer bars indicate greater variability. The vertical sorting is based on the selected criterion (e.g., original potential).</p>
            </div>
        </div>

    </div><!-- /container -->

    <!-- Dataset JSON (no longer used, left for reference) -->
    <script type="application/json" id="modelData">[]</script>

    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Elements ---
            const filtersContainer = document.getElementById('filters');
            const tabs = document.querySelectorAll('.tab');
            const tabContents = document.querySelectorAll('.tab-content');
            const ctxMatching = document.getElementById('chartMatching').getContext('2d');
            const ctxPotenzialeCosto = document.getElementById('chartPotenzialeCosto').getContext('2d');
            const ctxSimilarita = document.getElementById('chartSimilarita').getContext('2d');
            const ctxCandlestick = document.getElementById('chartCandlestick').getContext('2d');
            const scatterLegendContainer = document.getElementById('scatterLegend'); // Custom legend container
            const manualUploadSection = document.getElementById('manualUploadSection');
            const csvFileInput = document.getElementById('csvFileInput');
            const sortOrderSelect = document.getElementById('sortOrderSelect');

            // --- Data and State ---
            let allData = [];
            let chartInstances = {}; // To keep track of active charts and destroy them
            const highlightedCompanies = new Set(); // Companies with active highlight
            let highlightIntervalId = null;
            let highlightPulseState = false;
            let filtersChangeBound = false;

            // --- Colors for companies ---
            // Palette optimized for 12 groups with maximum visual differentiation
            const companyColorMap = {
                'OpenAI': '#3498db',           // Bright blue
                'Anthropic': '#e67e22',        // Orange
                'Mistral AI': '#27ae60',       // Emerald green
                'Meta': '#9b59b6',             // Purple
                'Google': '#e74c3c',           // Red
                'DeepSeek': '#16a085',         // Dark teal
                'Alibaba': '#f39c12',          // Golden orange
                'Microsoft': '#2980b9',        // Dark blue
                'Hidden': '#34495e',           // Anthracite gray
                'Xai': '#c0392b',              // Dark red
                'Minimax': '#8e44ad',          // Dark purple
                'IBM': '#d35400',              // Burnt orange
                'Other': '#2c3e50'             // Blue gray dark
            };

            // --- Symbols for companies ---
            // Half circles, half other symbols to improve visual differentiation
            const companySymbolMap = {
                'OpenAI': 'circle',            // Circle
                'Anthropic': 'cross',          // Cross
                'Mistral AI': 'circle',        // Circle
                'Meta': 'triangle',            // Triangle
                'Google': 'circle',            // Circle
                'DeepSeek': 'star',            // Star
                'Alibaba': 'circle',           // Circle
                'Microsoft': 'rect',           // Square
                'Hidden': 'circle',            // Circle
                'Xai': 'crossRot',             // Rotated cross
                'Minimax': 'rectRounded',      // Rounded square
                'IBM': 'circle',               // Circle
                'Other': 'triangle'           // Triangle
            };

            const ACCURACY_THRESHOLD = 90;
            const POTENZIALE_THRESHOLD = 29250;
            const POTENZIALE_THRESHOLD_LABEL = POTENZIALE_THRESHOLD.toLocaleString('en-US');
            const potenzialeThresholdPlugin = {
                id: 'potenzialeThresholdLine',
                afterDatasetsDraw(chart, args, pluginOptions) {
                    const options = pluginOptions || chart.options.plugins?.potenzialeThresholdLine;
                    if (!options) return;
                    const threshold = typeof options.value === 'number' ? options.value : POTENZIALE_THRESHOLD;
                    const xScale = chart.scales?.x;
                    if (!xScale || !chart.chartArea) return;
                    const xPixel = xScale.getPixelForValue(threshold);
                    if (!Number.isFinite(xPixel)) return;
                    const { top, bottom, left, right } = chart.chartArea;
                    if (xPixel < left || xPixel > right) return;

                    const ctx = chart.ctx;
                    ctx.save();
                    ctx.strokeStyle = options.color || '#27ae60';
                    ctx.lineWidth = options.lineWidth || 1.5;
                    ctx.setLineDash(options.dash || [6, 4]);
                    ctx.beginPath();
                    ctx.moveTo(xPixel, top);
                    ctx.lineTo(xPixel, bottom);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    const formattedThreshold = typeof threshold === 'number' && threshold.toLocaleString
                        ? threshold.toLocaleString('en-US')
                        : threshold;
                    const label = options.label || `Potential ≥ ${formattedThreshold}`;
                    ctx.fillStyle = options.color || '#27ae60';
                    ctx.font = options.font || '12px sans-serif';
                    ctx.textBaseline = 'top';
                    ctx.textAlign = 'center';
                    ctx.fillText(label, xPixel, top + 8);
                    ctx.restore();
                }
            };
            Chart.register(potenzialeThresholdPlugin);

            function getCompany(item) {
                return (item.azienda && String(item.azienda).trim()) || 'Other';
            }

            function getAccuracyPercentage(item) {
                if (typeof item.percent_true === 'number') {
                    return item.percent_true;
                }
                const parsed = parseFloat(item.percent_true);
                if (!Number.isNaN(parsed)) {
                    return parsed;
                }
                if (typeof item.true === 'number' && typeof item.total_query === 'number' && item.total_query) {
                    return (item.true / item.total_query) * 100;
                }
                return null;
            }

            // --- Initialization ---
            try {
                loadData();
                csvFileInput.addEventListener('change', handleManualUpload);
            } catch (error) {
                console.error("Error during initialization:", error);
                alert("Unable to load data or initialize the dashboard.");
            }

            // --- Data loading ---
            async function loadData() {
                try {
                    const response = await fetch('dati.csv');
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const csvText = await response.text();
                    parseCsvData(csvText);
                } catch (error) {
                    console.warn("Unable to load dati.csv automatically. Enabling manual upload.", error);
                    manualUploadSection.style.display = 'block';
                }
            }

            function handleManualUpload() {
                const file = csvFileInput.files[0];
                if (file) {
                    Papa.parse(file, {
                        header: true,
                        dynamicTyping: true,
                        complete: function(results) {
                            if (results.errors.length) {
                                console.error("Error parsing CSV:", results.errors);
                                alert("Error parsing CSV file. Check the format.");
                                return;
                            }
                            allData = results.data.filter(row => Object.values(row).some(x => x !== null && x !== '')); // Filter empty rows
                            if (allData.length === 0) {
                                alert("The uploaded CSV file is empty or contains no valid data.");
                                return;
                            }
                            manualUploadSection.style.display = 'none';
                            initializeDashboard();
                        },
                        error: function(err) {
                            console.error("Error reading file:", err);
                            alert("Error reading file.");
                        }
                    });
                } else {
                    alert("Select a CSV file before loading.");
                }
            }

            function parseCsvData(csvText) {
                Papa.parse(csvText, {
                    header: true,
                    dynamicTyping: true,
                    complete: function(results) {
                        if (results.errors.length) {
                            console.error("Error parsing CSV:", results.errors);
                            alert("Error parsing CSV file. Check the format.");
                            return;
                        }
                        allData = results.data.filter(row => Object.values(row).some(x => x !== null && x !== ''));
                        if (allData.length === 0) {
                            alert("The CSV file is empty or contains no valid data.");
                            manualUploadSection.style.display = 'block';
                            return;
                        }
                        initializeDashboard();
                    },
                    error: function(err) {
                        console.error("Error parsing CSV:", err);
                        alert("Error parsing automatically loaded CSV.");
                        manualUploadSection.style.display = 'block';
                    }
                });
            }

            function initializeDashboard() {
                resetHighlights();
                buildFilters();
                setupTabs();
                buildCharts(); // Build initial charts
                // Make reactive: rebuild charts on every checkbox change
                if (!filtersChangeBound) {
                    filtersContainer.addEventListener('change', () => {
                        buildCharts();
                    });
                    sortOrderSelect.addEventListener('change', () => {
                        buildCharts();
                    });
                    filtersChangeBound = true;
                }
            }

            // --- Building checkbox filters ---
            function buildFilters() {
                filtersContainer.innerHTML = '';
                const byCompany = groupBy(allData, item => getCompany(item));
                const companyNames = Object.keys(byCompany).sort((a,b) => a.localeCompare(b));

                companyNames.forEach(company => {
                    const models = byCompany[company].map(d => d.modello).sort((a,b) => a.localeCompare(b));

                    const group = document.createElement('div');
                    group.className = 'company-group';

                    const header = document.createElement('div');
                    header.className = 'company-header';
                    
                    const headerLeft = document.createElement('div');
                    headerLeft.className = 'company-header-left';
                    
                    const collapseToggle = document.createElement('span');
                    collapseToggle.className = 'collapse-toggle';
                    collapseToggle.textContent = '▾';
                    collapseToggle.setAttribute('aria-label', 'Expand/Collapse');
                    
                    const headerLabel = document.createElement('label');
                    const companyCheckbox = document.createElement('input');
                    companyCheckbox.type = 'checkbox';
                    companyCheckbox.className = 'company-checkbox';
                    companyCheckbox.dataset.company = company;
                    companyCheckbox.checked = true; // selezionato di default
                    headerLabel.appendChild(companyCheckbox);
                    const headerText = document.createTextNode(' ' + company);
                    headerLabel.appendChild(headerText);
                    
                    headerLeft.appendChild(collapseToggle);
                    headerLeft.appendChild(headerLabel);
                    header.appendChild(headerLeft);

                    const highlightButton = document.createElement('button');
                    highlightButton.type = 'button';
                    highlightButton.className = 'highlight-toggle';
                    highlightButton.dataset.company = company;
                    highlightButton.textContent = 'Highlight';
                    highlightButton.addEventListener('click', (e) => {
                        e.stopPropagation(); // Prevents group toggle when clicking Highlight
                        toggleCompanyHighlight(company, highlightButton);
                    });
                    updateHighlightButtonState(highlightButton, company);
                    header.appendChild(highlightButton);
                    
                    // Toggle group collapse
                    header.addEventListener('click', (e) => {
                        // Don't toggle if click is on checkbox or Highlight button
                        if (e.target === companyCheckbox || e.target === highlightButton || e.target.closest('.highlight-toggle')) {
                            return;
                        }
                        group.classList.toggle('collapsed');
                    });
                    
                    group.appendChild(header);

                    const list = document.createElement('div');
                    list.className = 'model-list';
                    models.forEach(model => {
                        const item = document.createElement('label');
                        item.className = 'model-item';
                        const cb = document.createElement('input');
                        cb.type = 'checkbox';
                        cb.className = 'model-checkbox';
                        cb.value = model;
                        cb.dataset.company = company;
                        // Disabled by default only GEMINI 3.0 because it has zero data that skews the charts
                        cb.checked = model !== 'GEMINI 3.0';
                        item.appendChild(cb);
                        item.appendChild(document.createTextNode(model));
                        list.appendChild(item);
                    });
                    group.appendChild(list);

                    // Bulk: check company -> check all models
                    companyCheckbox.addEventListener('change', (e) => {
                        const checked = e.target.checked;
                        list.querySelectorAll('input.model-checkbox').forEach(cb => {
                            cb.checked = checked;
                        });
                        // trigger change to rebuild charts
                        filtersContainer.dispatchEvent(new Event('change'));
                    });

                    // Keep indeterminate state for header
                    const updateCompanyCheckboxState = () => {
                        const cbs = Array.from(list.querySelectorAll('input.model-checkbox'));
                        const numChecked = cbs.filter(cb => cb.checked).length;
                        companyCheckbox.indeterminate = numChecked > 0 && numChecked < cbs.length;
                        companyCheckbox.checked = numChecked === cbs.length;
                    };
                    list.addEventListener('change', updateCompanyCheckboxState);
                    // Update initial state of company checkbox after creating all models
                    updateCompanyCheckboxState();

                    filtersContainer.appendChild(group);
                });
            }

            function groupBy(array, keyGetter) {
                const map = {};
                array.forEach((item) => {
                    const key = keyGetter(item) || 'Other';
                    if (!map[key]) map[key] = [];
                    map[key].push(item);
                });
                return map;
            }

            function getSelectedModels() {
                return Array.from(document.querySelectorAll('input.model-checkbox:checked')).map(cb => cb.value);
            }

            function destroyCharts() {
                stopHighlightTimer();
                Object.keys(chartInstances).forEach(key => {
                    if (chartInstances[key]) {
                        chartInstances[key].destroy();
                        chartInstances[key] = null;
                    }
                });
                 // Also clean up the custom legend
                scatterLegendContainer.innerHTML = '';
            }

            function buildCharts() {
                destroyCharts();
                const selectedModels = getSelectedModels();
                const filteredData = allData.filter(item => selectedModels.includes(item.modello));
                if (filteredData.length === 0) {
                    console.warn('No model selected or filtered data is empty.');
                    return;
                }
                buildMatchingChart(filteredData);
                buildPotenzialeCostoChart(filteredData);
                buildSimilaritaChart(filteredData);
                buildCandlestickChart(filteredData);
            }

            // --- Charts ---
            function buildMatchingChart(data) {
                const sortedData = [...data].sort((a, b) => b.true - a.true);
                const labels = sortedData.map(item => item.modello);
                const trueData = sortedData.map(item => item.true);
                const falseData = sortedData.map(item => item.false);

                // Dynamic height to include all labels when showing horizontal bars
                const barsCount = Math.max(labels.length, 1);
                const pixelsPerBar = 28;
                const minHeightPx = 350;
                const targetHeight = Math.max(minHeightPx, barsCount * pixelsPerBar);
                ctxMatching.canvas.parentNode.style.height = `${targetHeight}px`;

                chartInstances.matching = new Chart(ctxMatching, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [
                            { label: 'True', data: trueData, backgroundColor: 'rgba(75, 192, 192, 0.7)', borderColor: 'rgba(75, 192, 192, 1)', borderWidth: 1 },
                            { label: 'False', data: falseData, backgroundColor: 'rgba(255, 99, 132, 0.7)', borderColor: 'rgba(255, 99, 132, 1)', borderWidth: 1 }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        indexAxis: 'y',
                        plugins: {
                            title: { display: false },
                            tooltip: { mode: 'index', intersect: false }
                        },
                        scales: {
                            x: {
                                stacked: true,
                                beginAtZero: true,
                                title: { display: true, text: 'Number of Queries' }
                            },
                            y: {
                                stacked: true,
                                grid: { display: false },
                                ticks: { autoSkip: false, font: { size: 11 } }
                            }
                        },
                        animation: { duration: 300 }
                    }
                });
            }

            function buildPotenzialeCostoChart(data) {
                const scatterData = [];
                const companiesPresent = new Set();

                data.forEach(item => {
                    const company = getCompany(item);
                    const color = companyColorMap[company] || companyColorMap['Other'];
                    const symbol = companySymbolMap[company] || companySymbolMap['Other'];
                    const accuracy = getAccuracyPercentage(item);
                    const baseRadius = accuracy !== null && accuracy >= ACCURACY_THRESHOLD ? 9 : 7;
                    const baseBorderWidth = accuracy !== null && accuracy >= ACCURACY_THRESHOLD ? 2.5 : 1.5;
                    const similarityValue = typeof item.similarita_media === 'number'
                        ? item.similarita_media
                        : parseFloat(item.similarita_media);
                    scatterData.push({
                        x: item.potenziale,
                        y: item.costo_euro,
                        label: item.modello,
                        company: company,
                        baseColor: color,
                        baseBorderColor: adjustColor(color, -20),
                        baseSymbol: symbol,
                        accuracy: accuracy,
                        similarity: Number.isFinite(similarityValue) ? similarityValue : null,
                        baseRadius,
                        baseBorderWidth
                    });
                    companiesPresent.add(company);
                });

                buildCustomLegend(companiesPresent);

                chartInstances.potenzialeCosto = new Chart(ctxPotenzialeCosto, {
                    type: 'scatter',
                    data: {
                        datasets: [{
                            label: 'Modelli',
                            data: scatterData,
                            pointBackgroundColor: scatterData.map(point => point.baseColor),
                            pointBorderColor: scatterData.map(point => point.baseBorderColor),
                            pointBorderWidth: scatterData.map(point => point.baseBorderWidth),
                            pointRadius: scatterData.map(point => point.baseRadius),
                            pointHoverRadius: scatterData.map(point => point.baseRadius + 3),
                            pointStyle: scatterData.map(point => point.baseSymbol)
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: { display: false },
                            legend: { display: false },
                            potenzialeThresholdLine: {
                                value: POTENZIALE_THRESHOLD,
                                label: `90% accuracy ≈ ${POTENZIALE_THRESHOLD_LABEL}`,
                                color: '#27ae60'
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const item = context.raw;
                                        const accuracyText = typeof item.accuracy === 'number'
                                            ? `, Acc: ${item.accuracy.toFixed(1)}%`
                                            : '';
                                        const similarityText = typeof item.similarity === 'number'
                                            ? `, Sim: ${item.similarity.toFixed(1)}%`
                                            : '';
                                        return `${item.label} [${item.company}]: (Pot: ${item.x}, Cost: ${Number(item.y).toFixed(2)} €${accuracyText}${similarityText})`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: { type: 'linear', position: 'bottom', title: { display: true, text: 'Potential' }, grid: { color: 'rgba(0,0,0,0.05)'} },
                            y: { beginAtZero: true, title: { display: true, text: 'Cost (€)' }, grid: { color: 'rgba(0,0,0,0.05)'} }
                        },
                        animation: { duration: 300 }
                    }
                });
                ensureHighlightTimer();
            }

            function buildSimilaritaChart(data) {
                const sortedData = [...data].sort((a, b) => b.similarita_media - a.similarita_media);
                const labels = sortedData.map(item => item.modello);
                const similaritaData = sortedData.map(item => item.similarita_media);

                // Dynamically resize container height to avoid label clipping
                // Height per bar (in px) + minimum height for small screens
                const barsCount = Math.max(labels.length, 1);
                const pixelsPerBar = 28; // adjust if you want more/less vertical space per label
                const minHeightPx = 350;
                const targetHeight = Math.max(minHeightPx, barsCount * pixelsPerBar);
                ctxSimilarita.canvas.parentNode.style.height = `${targetHeight}px`;

                chartInstances.similarita = new Chart(ctxSimilarita, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Average Similarity (%)', data: similaritaData,
                            backgroundColor: 'rgba(255, 159, 64, 0.7)', borderColor: 'rgba(255, 159, 64, 1)', borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true, maintainAspectRatio: false, indexAxis: 'y',
                        plugins: { title: { display: false }, legend: { display: false } },
                        scales: {
                            x: { beginAtZero: true, title: { display: true, text: 'Average Similarity (%)' } },
                            y: {
                                grid: { display: false },
                                ticks: {
                                    autoSkip: false, // show all labels
                                    font: { size: 11 }
                                }
                            }
                        },
                        animation: { duration: 300 }
                    }
                });
            }

            function buildCandlestickChart(data) {
                const sortOrder = sortOrderSelect.value;

                // Calculate maximum standard deviation for normalization
                const allDeviazioni = allData
                    .map(d => typeof d.deviazione_std === 'number' ? d.deviazione_std : parseFloat(d.deviazione_std))
                    .filter(d => Number.isFinite(d));
                const maxDev = Math.max(...allDeviazioni);

                // Sort data based on selection (using original values)
                const sortedData = [...data].sort((a, b) => {
                    const potA = typeof a.potenziale === 'number' ? a.potenziale : parseFloat(a.potenziale);
                    const potB = typeof b.potenziale === 'number' ? b.potenziale : parseFloat(b.potenziale);
                    const devA = typeof a.deviazione_std === 'number' ? a.deviazione_std : parseFloat(a.deviazione_std);
                    const devB = typeof b.deviazione_std === 'number' ? b.deviazione_std : parseFloat(b.deviazione_std);

                    switch (sortOrder) {
                        case 'potenziale_desc':
                            return potB - potA;
                        case 'deviazione_asc':
                            return devA - devB;
                        case 'deviazione_desc':
                            return devB - devA;
                        case 'potenziale_asc':
                        default:
                            return potA - potB;
                    }
                });

                // Update chart title
                const chartTitle = document.getElementById('candlestickChartTitle');
                const titleMap = {
                    'potenziale_asc': 'Normalized Variation (Std Dev) - Sorted by Potential Ascending',
                    'potenziale_desc': 'Normalized Variation (Std Dev) - Sorted by Potential Descending',
                    'deviazione_asc': 'Normalized Variation (Std Dev) - Sorted by Std Deviation Ascending',
                    'deviazione_desc': 'Normalized Variation (Std Dev) - Sorted by Std Deviation Descending'
                };
                chartTitle.textContent = titleMap[sortOrder] || 'Normalized Variation (Std Dev)';

                const labels = sortedData.map(item => item.modello);
                const floatingBarData = [];

                sortedData.forEach(item => {
                    const potenziale = typeof item.potenziale === 'number' ? item.potenziale : parseFloat(item.potenziale);
                    const deviazioneStd = typeof item.deviazione_std === 'number' ? item.deviazione_std : parseFloat(item.deviazione_std);

                    if (!Number.isFinite(potenziale) || !Number.isFinite(deviazioneStd)) {
                        return; // Skip invalid data
                    }

                    // Normalize deviation based on maximum deviation, to make it visible
                    // The scale is 45 to have some margin (from 5 to 95)
                    const deviazioneNorm = maxDev > 0 ? (deviazioneStd / maxDev) * 45 : 0;

                    const company = getCompany(item);
                    const color = companyColorMap[company] || companyColorMap['Other'];

                    floatingBarData.push({
                        x: [50 - deviazioneNorm, 50 + deviazioneNorm], // Centered at 50
                        y: item.modello,
                        company: company,
                        color: color,
                        potenzialeOriginal: potenziale,
                        deviazioneStdOriginal: deviazioneStd,
                        centroGrafico: 50 // Center point for median line
                    });
                });

                if (floatingBarData.length === 0) {
                    console.warn('No valid data for floating bar chart.');
                    return;
                }

                // Dynamic height to include all labels
                const barsCount = Math.max(labels.length, 1);
                const pixelsPerBar = 28;
                const minHeightPx = 400;
                const targetHeight = Math.max(minHeightPx, barsCount * pixelsPerBar);
                ctxCandlestick.canvas.parentNode.style.height = `${targetHeight}px`;

                chartInstances.candlestick = new Chart(ctxCandlestick, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Normalized Variation (Std Dev)',
                            data: floatingBarData.map(d => d.x),
                            backgroundColor: floatingBarData.map(d => d.color),
                            borderColor: floatingBarData.map(d => adjustColor(d.color, -30)),
                            borderWidth: 1,
                            barPercentage: 0.6,
                            categoryPercentage: 0.8
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        indexAxis: 'y',
                        plugins: {
                            title: { display: false },
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const index = context.dataIndex;
                                        const dataPoint = floatingBarData[index];
                                        if (!dataPoint) return '';
                                        return [
                                            `Company: ${dataPoint.company}`,
                                            `Potential (Original): ${dataPoint.potenzialeOriginal.toLocaleString('en-US')}`,
                                            `Std Dev (Original): ${dataPoint.deviazioneStdOriginal.toFixed(2)}`
                                        ];
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                min: 0,
                                max: 100,
                                title: { display: true, text: 'Normalized Variation (based on Std Dev)' },
                                grid: { color: 'rgba(0,0,0,0.05)' }
                            },
                            y: {
                                grid: { display: false },
                                ticks: {
                                    autoSkip: false,
                                    font: { size: 11 }
                                }
                            }
                        },
                        animation: { duration: 300 }
                    },
                    plugins: [{
                        id: 'medianLine',
                        afterDatasetsDraw(chart) {
                            const ctx = chart.ctx;
                            const meta = chart.getDatasetMeta(0);
                            const xScale = chart.scales.x;

                            meta.data.forEach((bar, index) => {
                                const dataPoint = floatingBarData[index];
                                if (!dataPoint) return;

                                const medianX = xScale.getPixelForValue(dataPoint.centroGrafico);

                                if (!Number.isFinite(medianX)) return;

                                ctx.save();
                                ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)';
                                ctx.lineWidth = 1.5;
                                ctx.beginPath();
                                ctx.moveTo(medianX, bar.y - bar.height / 2);
                                ctx.lineTo(medianX, bar.y + bar.height / 2);
                                ctx.stroke();
                                ctx.restore();
                            });
                        }
                    }]
                });
            }

            // --- Helper to draw symbols in legend ---
            function createSymbolCanvas(symbol, color, size = 12) {
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = color;
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                
                const centerX = size / 2;
                const centerY = size / 2;
                const radius = size / 2 - 2;
                
                switch(symbol) {
                    case 'circle':
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                        ctx.fill();
                        break;
                    case 'cross':
                        ctx.beginPath();
                        ctx.moveTo(centerX, 2);
                        ctx.lineTo(centerX, size - 2);
                        ctx.moveTo(2, centerY);
                        ctx.lineTo(size - 2, centerY);
                        ctx.stroke();
                        break;
                    case 'crossRot':
                        ctx.save();
                        ctx.translate(centerX, centerY);
                        ctx.rotate(Math.PI / 4);
                        ctx.beginPath();
                        ctx.moveTo(0, -radius);
                        ctx.lineTo(0, radius);
                        ctx.moveTo(-radius, 0);
                        ctx.lineTo(radius, 0);
                        ctx.stroke();
                        ctx.restore();
                        break;
                    case 'triangle':
                        ctx.beginPath();
                        ctx.moveTo(centerX, 2);
                        ctx.lineTo(2, size - 2);
                        ctx.lineTo(size - 2, size - 2);
                        ctx.closePath();
                        ctx.fill();
                        break;
                    case 'star':
                        const spikes = 5;
                        const outerRadius = radius;
                        const innerRadius = radius * 0.5;
                        ctx.beginPath();
                        for (let i = 0; i < spikes * 2; i++) {
                            const radius = i % 2 === 0 ? outerRadius : innerRadius;
                            const angle = (i * Math.PI) / spikes - Math.PI / 2;
                            const x = centerX + radius * Math.cos(angle);
                            const y = centerY + radius * Math.sin(angle);
                            if (i === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        ctx.closePath();
                        ctx.fill();
                        break;
                    case 'rect':
                        ctx.fillRect(2, 2, size - 4, size - 4);
                        break;
                    case 'rectRounded':
                        const cornerRadius = 2;
                        ctx.beginPath();
                        ctx.moveTo(2 + cornerRadius, 2);
                        ctx.lineTo(size - 2 - cornerRadius, 2);
                        ctx.quadraticCurveTo(size - 2, 2, size - 2, 2 + cornerRadius);
                        ctx.lineTo(size - 2, size - 2 - cornerRadius);
                        ctx.quadraticCurveTo(size - 2, size - 2, size - 2 - cornerRadius, size - 2);
                        ctx.lineTo(2 + cornerRadius, size - 2);
                        ctx.quadraticCurveTo(2, size - 2, 2, size - 2 - cornerRadius);
                        ctx.lineTo(2, 2 + cornerRadius);
                        ctx.quadraticCurveTo(2, 2, 2 + cornerRadius, 2);
                        ctx.closePath();
                        ctx.fill();
                        break;
                    default:
                        // Default to circle
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                        ctx.fill();
                }
                
                return canvas;
            }

            // --- Custom legend (for companies) ---
            function buildCustomLegend(companies) {
                scatterLegendContainer.innerHTML = '';
                const sortedCompanies = Array.from(companies).sort();
                sortedCompanies.forEach(company => {
                    const color = companyColorMap[company] || companyColorMap['Other'];
                    const symbol = companySymbolMap[company] || companySymbolMap['Other'];
                    const li = document.createElement('li');
                    li.dataset.company = company;
                    
                    // Create canvas with symbol instead of simple span
                    const symbolCanvas = createSymbolCanvas(symbol, color, 12);
                    symbolCanvas.style.marginRight = '5px';
                    symbolCanvas.style.verticalAlign = 'middle';
                    
                    const textNode = document.createTextNode(' ' + company);
                    li.appendChild(symbolCanvas);
                    li.appendChild(textNode);
                    
                    // Make clickable for toggle highlight
                    li.addEventListener('click', () => {
                        // Find the corresponding Highlight button in the sidebar
                        const highlightButton = document.querySelector(`.highlight-toggle[data-company="${company}"]`);
                        if (highlightButton) {
                            toggleCompanyHighlight(company, highlightButton);
                            updateLegendItemState(li, company);
                        }
                    });
                    
                    // Update initial state
                    updateLegendItemState(li, company);
                    
                    scatterLegendContainer.appendChild(li);
                });
            }
            
            function updateLegendItemState(legendItem, company) {
                const isActive = highlightedCompanies.has(company);
                legendItem.classList.toggle('active', isActive);
            }
            
            function refreshLegendItems() {
                document.querySelectorAll('#scatterLegend li').forEach(li => {
                    const company = li.dataset.company;
                    if (company) {
                        updateLegendItemState(li, company);
                    }
                });
            }

            // --- Color helper ---
            function adjustColor(color, amount) {
                return '#' + color.replace(/^#/, '').replace(/../g, c => ('0'+Math.min(255, Math.max(0, parseInt(c, 16) + amount)).toString(16)).substr(-2));
            }

            function toggleCompanyHighlight(company, button) {
                if (highlightedCompanies.has(company)) {
                    highlightedCompanies.delete(company);
                } else {
                    highlightedCompanies.add(company);
                }
                updateHighlightButtonState(button, company);
                refreshLegendItems(); // Also update the legend
                ensureHighlightTimer();
            }

            function updateHighlightButtonState(button, company) {
                const isActive = highlightedCompanies.has(company);
                button.classList.toggle('active', isActive);
                button.setAttribute('aria-pressed', isActive ? 'true' : 'false');
            }

            function refreshHighlightButtons() {
                document.querySelectorAll('.highlight-toggle').forEach(button => {
                    const company = button.dataset.company;
                    updateHighlightButtonState(button, company);
                });
            }

            function resetHighlights() {
                highlightedCompanies.clear();
                stopHighlightTimer();
                refreshHighlightButtons();
                refreshLegendItems(); // Also update the legend
                updateScatterHighlight();
            }

            function ensureHighlightTimer() {
                const hasHighlightedPoints = updateScatterHighlight();
                if (highlightedCompanies.size === 0 || !hasHighlightedPoints) {
                    stopHighlightTimer();
                    return;
                }
                if (!highlightIntervalId) {
                    highlightIntervalId = setInterval(() => {
                        highlightPulseState = !highlightPulseState;
                        updateScatterHighlight();
                    }, 500);
                }
            }

            function stopHighlightTimer({ resetPulse = true } = {}) {
                if (highlightIntervalId) {
                    clearInterval(highlightIntervalId);
                    highlightIntervalId = null;
                }
                if (resetPulse) {
                    highlightPulseState = false;
                }
            }

            function updateScatterHighlight() {
                const chart = chartInstances.potenzialeCosto;
                if (!chart) return false;
                const dataset = chart.data.datasets?.[0];
                if (!dataset || !Array.isArray(dataset.data)) return false;

                let hasHighlightedPoint = false;

                dataset.pointRadius = dataset.data.map(point => {
                    const isHighlighted = highlightedCompanies.has(point.company);
                    if (isHighlighted) hasHighlightedPoint = true;
                    if (!isHighlighted) return point.baseRadius;
                    const pulseOffset = highlightPulseState ? 3 : 1;
                    return point.baseRadius + pulseOffset;
                });
                dataset.pointBackgroundColor = dataset.data.map(point => {
                    if (!highlightedCompanies.has(point.company)) return point.baseColor;
                    return highlightPulseState ? adjustColor(point.baseColor, 35) : adjustColor(point.baseColor, -35);
                });
                dataset.pointBorderColor = dataset.data.map(point => {
                    if (!highlightedCompanies.has(point.company)) return point.baseBorderColor;
                    return highlightPulseState ? adjustColor(point.baseBorderColor, 35) : adjustColor(point.baseBorderColor, -35);
                });
                dataset.pointBorderWidth = dataset.data.map(point => {
                    if (!highlightedCompanies.has(point.company)) return point.baseBorderWidth;
                    return highlightPulseState ? point.baseBorderWidth + 1 : point.baseBorderWidth + 0.5;
                });
                chart.update('none');
                return hasHighlightedPoint;
            }

            // Tabs
            function setupTabs() {
                tabs.forEach(tab => {
                    tab.addEventListener('click', () => {
                        tabs.forEach(t => t.classList.remove('active'));
                        tabContents.forEach(tc => tc.classList.remove('active'));
                        tab.classList.add('active');
                        const targetContent = document.querySelector(tab.dataset.target);
                        if (targetContent) {
                            targetContent.classList.add('active');
                        }
                        Object.values(chartInstances).forEach(chart => {
                            if (chart && typeof chart.resize === 'function') {
                                setTimeout(() => chart.resize(), 0);
                            }
                        });
                    });
                });
            }
        });
    </script>

</body>
</html>
